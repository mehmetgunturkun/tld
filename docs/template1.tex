\documentclass{article}

\begin{document}
    \section{TLD Implementattion}
        \paragraph{}
            TLD implementation is based on three main modules such as: Tracker, Detector and Learner (Integrator).
            Tracker and Detector modules are completely independent from each other.
            However, Integrator evaluate two separate results from Tracker and Detector, validates, combines,
            a reasonable result and sends feedback to detector in order to rule out false positives and false negatives
            if necessary.
        \subsection{Tracker}
            \paragraph{}
                Tracker takes two consequtive frames and a bounding box, containing the target object within the first image.
                Tracker's main task is to estimate the location of the bounding box in the second frame or to decide whether the
                target object is still visible. Basically, tracker generates points in the given bounding box,
                tracks each point from first frame to second frame, filter the reliable ones and estimates
                the overall displacement with reliable points.
            \paragraph{Point Generation}
                In order to generate points in the given box, we divide given box into 10 equals
                parts in both directions: x and y. Every corner that horizontal and vertical stripes meet, we generate
                new point. As a result, we have 10x10 grid on the box and 100 points to track.
                //TODO Figure is coming here!
            \paragraph{Point Tracking}
                TLD uses pyramidal lucas-kanade tracker, which is already implemented in OpenCV, to track each point from frame
                to frame; but instead of tracking one way, we track the points, previous operation has end up, backwards.
                This forward-backward tracking gives us a good âˆ«metric for evaluation of reliability of points.
                \textbf{I can explain flags and parameters in calcOpticalFlowPyrLK?}
            \paragraph{Filtering Reliable Points}
                At this point, we have point to point correspondences with forward backward error. However, we still do not know which points
                are really tracked successfully. This is why, we apply normalized cross correlation between points to decide that
                still coordinates point to the same location of object or shifted away.
                Besides ncc error, we already have forward-backward error. With these error metrics, we apply median filtering to points and eliminate outliers.
                With forward -backward error validation, we can know that if we track backwards, we should end up with the same point.
            \paragraph{Relocation of Box}
                At the end of the tracking process, we have points and relatively robust displacements for each of them.
                With these displacements, we, again, get the median value of displacements in two direction and add
                to the coordinates of box respectively so that we can track object by tracking points
                on the object
        \subsection{Detector}
            \paragraph{}
                Detectors main job is to return candidate boxes that possibly enclosing the object. In order to find
                detect object instance in given frame, initially, detector generates boxes by slidinig window in different sizes,
                along the image. After that, for each box, it is need to be decided whether the object is included or not.
                This part of the process is basically a classification problem. To solve the problem, 3 stages are designed
                in detector such as: Variance Classifier, Ensemble Classifier and Nearest Neighbour Classifier.

                \paragraph{Variance Classifier} is the simplest classifier along the process, for given box it computes
                the variance and compares with variance of the first box that user already has selected.
                If the variance of the particular box is less than half of the first box's variance then it is
                eliminated.

                \paragraph{Ensemble Classifier} is the second classifier in the detection process. Ensemble Classifier has
                \emph{n} base classifiers which store \emph{m} horizontal and vertical comparisons.
                Every base classifier make these comparison and for each comparison it outputs a bit: 1 or 0.
                As a result of all comparisons, for each box, we have an array of bits which has \emph{m} elements..
                Every base classifier stores  how many positive and negative boxes which has generated same array of bits.

                \paragraph{Nearest Neighbor Classifier} is the last and most intensive classifier in the process.
                An object model, which is simply two list of bounding boxes that are labelled as positive and negative, is stored
                within this module. When new box came to be classified, Nearest Neighbor Classifier compares the sample with all
                boxes in positive and negative list and takes the highest similarity from both lists. Divides them and if the score
                is higher than threshold then sample is classified as positive, otherwise it is eliminated.
        \subsection{Learner}
            \paragraph{}
                Learners job is to reason out the tracking result and detection result.
                \begin{itemize}
                    \item How to validate when Tracker tracks given box?
                    \item How to decide whether detector or tracker is valid?
                    \item All possible cases, etc?
                \end{itemize}
\end{document}
